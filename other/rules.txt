Поток (Stream) не копирует данные коллекции в кучу или стек. Он создает объект,
который знает как пройтись по исходной коллекции и какие операции применить.
Он позволяет выполнять операции без изменения исходной коллекции.

members.stream()
       .filter(p -> p.age > 20)
       .map(p -> p.name)
       .forEach(System.out::println);
Здесь создаются сразу 3 объекта:
1. Поток Stream<Person>
2. Объект FilterOp, который хранит ссылку на функцию p -> p.age > 20
3. Объект MapOp, который хранит функцию p -> p.name

Промежуточные операции - это операции, которые подготавливают поток. Они начинают
обрабатывать только когда вызывается терминальная операция. Они возвращают
не результат, а новый поток, который можно дальше обрабатывать.

Терминальные операции - это операции, который завершают поток и возвращают результат.
Только терминальная операция запускает весь конвейер промежуточных операций. После
неё поток нельзя использовать повторно.

Некоторые терминальные операции могут не иметь результата, поэтому чтобы не возвращать
null, они используют безопасную обёртку Optional. А уже у этого объекта есть методы:
Метод	                            Что делает
.get()	                            возвращает значение, но выбросит ошибку, если пусто
.orElse(null)	                     возвращает значение или null, если пусто
.orElseGet(() -> new Person(...))	возвращает значение или создаёт новое
.isPresent()	                     проверяет, есть ли значение


Компаратор (Comparator) - функциональный интерфейс. Он описывает каким должен быть
объект, чтобы уметь сравнивать два значения.
@FunctionalInterface
public interface Comparator<T> {
    int compare(T o1, T o2);
}

compare(T o1, T o2) - главный метод компаратора. 
возвращает:
1. отрицательное число, если o1 < o2,
2. ноль, если o1 == o2,
3. положительное число, если o1 > o2.

comparingInt - статический метод у Comparator, который создаёт новый компаратор.

раньше: Comparator<Person> byAge = (p1, p2) -> Integer.compare(p1.age, p2.age);
сейчас: Comparator<Person> byAge = Comparator.comparingInt(p -> p.age);
